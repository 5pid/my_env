#!/usr/local/bin/bash
# Fuzzy find file/dir

ff() {  find . -type f -iname "$1";}
fff() { find . -type f -iname "*$1*";}
fd() {  find . -type d -iname "$1";}
fdf() { find . -type d -iname "*$1*";}

# trash
function trash-old() {
    local trash_dir="$HOME/.Trash"

    local not_exist_trash_directory_message=">> $(tput setaf 1)Not exist trash directory:$(tput sgr0) "$trash_dir
    local trash_status_message="\n  $(tput setaf 7)[TRASH_STATUS] TOTAL: $(find ${trash_dir} | wc -l | xargs) | SIZE: $(du -sh ${trash_dir} | cut -f1 | xargs)$(tput sgr0)\n"
    local confirm_message=">> $(tput setaf 3)$(tput bold)Do you want this work? [y/n]:$(tput sgr0) "
    local clear_trash_message=">> $(tput setaf 2)Empty a trash can$(tput sgr0)"
    local caution_directory_message=">> "

    # check trash directory 
    if [ ! -d "$trash_dir" ]; then
        echo -e "$not_exist_trash_directory_message" 1>&2
        return 
    fi
    
    # Set option
    local option
    local files=()
    # Set default option
    if [ -z $1 ]; then set -- "-h"; fi

    for arg in "$@"; do
        shift
        case "$arg" in
            "-h"|"-\?"|"--help")                   option="help";;
            "-c"|"--clear")                        option="clear";;
            "-cf"|"--clear-force")                 option="clear-force";;
            "-cfv")                                option="clear-force-verbose";;
            "-l"|"--list")                         option="list";;
            "-al"|"-la"|"--list-all"|"--all-list") option="list-all";;
            "-rf")                                 option="remove-force";;
            *)                                     [[ "$arg" =~ ^[^-].* ]] && files+=("$arg");;
        esac
    done

    #echo "[DEBUG] option: "$option
    #echo "[DEBUG] files: "${files[@]}

    # process sub options
    echo -e $trash_status_message # display trash status before working
    case "$option" in
        "help")
            cat <<< "here document"
            return;;   
        "clear")
            echo -e "$confirm_message"
            rm -rvi "${trash_dir}"/*; return;;
        "clear-force")
            rm -rf "${trash_dir}"/*
            echo -e $clear_trash_message; return;;
        "clear-force-verbose")
            rm -rfv "${trash_dir}"/*
            echo -e "$clear_trash_message"; return;;
        "list") 
            ls -l "$trash_dir"; return;;
        "list-all")
            ls -al "$trash_dir"; return;;
        "remove-force")
            remove_force=1;;
    esac
    
    # Validate files
    # - deprecated because of not support -P option of grep in macos
    # local regex_valid_to_file_name='(^|(?<=\s))(\/|$HOME|$HOME\/)($|(?=\s))'
    for file in "${files[@]}"; do
        # caution
        if [[ $file =~ ^(\/|$HOME|$HOME\/)$ ]]; then
            echo "${caution_directory_message}: "$file 1>&2
            return;
        fi
    done

    # Work
    if [[ $option == "remove-force" ]]; then
        local tty_state
        local yn
        echo -e ">> $(tput setaf 7)$(tput bold)rm -rf "${files[@]}$(tput sgr0)
        printf "$confirm_message"
        tty_state=$(stty -g)
        stty raw
        yn=$(dd bs=1 count=1 2> /dev/null)
        stty "$tty_state"
        echo

        case "$yn" in
            [yY])
                printf "%s\0" "${files[@]}" | xargs -I{} -0 rm -rfv {};;
            [nN])
                ;;
            *)
                ;;
        esac
    else
        printf "%s\0" "${files[@]}" | xargs -I{} -0 mv -v {} "$trash_dir"
    fi
    return
}